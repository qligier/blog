---
title: "How to enable JSON or YAML validation with JSON Schemas in IntelliJ"
date: 2026-01-03
draft: false
tags: ['Software', 'IDE', 'Development']
description: "The blog post is describing how to add support for specific JSON or YAML files in JetBrains IDEs from a
JSON Schema, quickly implementing some validation, annotation, code completion and other features."
---

<p>
    This is another article about plugin development for IntelliJ-based IDEs.
    In this article, I am describing how to implement some support for JSON or YAML files using a JSON Schema.
    While the JSON support is expected, the YAML support is a bit more surprising.
    It is possible because JSON and YAML are very similar formats, YAML 1.2 even being a superset of JSON.
</p>

<p>
    I recently implemented that trick in my plugin
    {{< a/ext "https://github.com/qligier/jetbrains-plugin-fss" "FHIR® and SUSHI Support" >}} to provide a better
    experience while working with a specific YAML file (the <code>sushi-config.yaml</code> file).
    I discovered that neat feature in the
    {{< a/ext "https://www.jetbrains.com/help/idea/yaml.html#json_schema" "YAML documentation" >}}, but I had to use the
    {{< a/ext "https://plugins.jetbrains.com/intellij-platform-explorer/extensions?extensions=JavaScript.JsonSchema.ProviderFactory" "IntelliJ Platform Explorer" >}}
    to discover how a plugin could register a new JSON Schema in the IDE.
    That topic isn't covered by the
    {{< a/ext "https://plugins.jetbrains.com/docs/intellij/welcome.html" "IntelliJ Platform SDK Documentation" >}}
    documentation, so I am sharing my findings here.
</p>

{{< h2 "Supported features" >}}

<p>
    The features automatically provided by the IntelliJ SDK (at the time of writing) when a JSON Schema is enabled are:
</p>

<ul>
    <li>Autocompletion suggestions based on the schema;</li>
    <li>Validation of values based on the defined type and constraints;</li>
    <li><code>description</code> fields are used to annotate the YAML elements;</li>
    <li>
        the <code>{{< a/ext "https://json-schema.org/understanding-json-schema/reference/type" "types" >}}</code> are
        properly enforced;
    </li>
    <li>
        <code>definitions</code> are properly handled internally, meaning the SDK is able to follow references;
    </li>
    <li>
        For {{< a/ext "https://json-schema.org/understanding-json-schema/reference/object" "objects" >}},
        <code>properties</code>, <code>minProperties</code> and <code>maxProperties</code> are supported.
    </li>
</ul>

<p>
    Notably, the following features are NOT supported:
</p>

<ul>
    <li>
        Despite setting
        <code>{{< a/ext "https://json-schema.org/understanding-json-schema/reference/object#additionalproperties" "additionalProperties" >}}</code>
        on an object, extra properties are not marked as errors;
    </li>
    <li>
        In arrays, <code>uniqueItems</code>, <code>minItems</code> and <code>maxItems</code> are not enforced (despite
        the object's equivalent <code>minProperties</code> and <code>maxProperties</code> being supported);
    </li>
</ul>

<p>
    There are many other features of JSON Schema that I did not test, so this list is not exhaustive.
    Overall, the support is good enough to provide a nice assistance to the user, because it's tightly integrated
    into the IDE.
    But if you're looking to perform a full validation of files against a JSON Schema, you may want to consider
    alternative implementations, because of the missing features listed above.
</p>

<p>
    For my plugin, I wanted to provide a better experience when editing the <code>sushi-config.yaml</code> file, not a
    full validation, so I'm satisfied with the current state of the support.
    Let's proceed to the implementation!
</p>

{{< h2 "The implementation" >}}

<p>
    Let's go into the implementation details.
    For these examples, I am using the
    {{< a/ext "https://github.com/JetBrains/intellij-platform-plugin-template" "IntelliJ Platform Plugin Template" >}},
    but your plugin structure may differ slightly.
</p>

<p>
    The implementation is straightforward, and requires three main steps: a JSON Schema, a provider class with its
    factory, and a registration in the plugin configuration file.
</p>

{{< h3 "A JSON Schema" >}}

<p>
    First, we need a JSON Schema to work with.
    Creating a JSON Schema is out of the scope of this article, but there are many resources online to help with that,
    and I found it rather easy to write one manually.
    I'm also sure there are good tools with graphical interfaces to help visualizing and editing the schemas.
</p>

<p>
    Once you have your schema, you need to add it to your plugin resources.
    In the plugin template structure, that would be under <em>my-plugin/src/main/resources/</em>.
    For this example, I simply named my schema file <code>schema.json</code>.
</p>

{{< h3 "A provider" >}}

<p>
    Next, we create a new class extending <code>JsonSchemaFileProvider</code> to provide our schema to the IDE.
    But that interface we are extending is not part of the standard IntelliJ API, but is an additional plugin that we
    need to declare as a build dependency in the Gradle configuration (despite its name, it's not a module but a plugin):
</p>

```properties {title="gradle.properties"}
platformBundledPlugins = com.intellij.modules.json
```

<p>Or with the regular <code>gradle.build.kts</code> file (with the IntelliJ Platform Gradle Plugin 2.0+):</p>

```kotlin {title="gradle.build.kts"}
dependencies {
    // …
    // IntelliJ Platform Gradle Plugin Dependencies Extension - read more: https://plugins.jetbrains.com/docs/intellij/tools-intellij-platform-gradle-plugin-dependencies-extension.html
    intellijPlatform {
        bundledPlugin("com.intellij.modules.json")
    }
}
```

<p>
    Now, we can implement our provider:
</p>

```kotlin {title="MyJsonSchemaProvider.kt"}
package org.jetbrains.plugins.template

import com.intellij.openapi.vfs.VirtualFile
import com.jetbrains.jsonSchema.extension.JsonSchemaFileProvider
import com.jetbrains.jsonSchema.extension.JsonSchemaProviderFactory
import com.jetbrains.jsonSchema.extension.SchemaType
import com.jetbrains.jsonSchema.impl.JsonSchemaVersion
import org.jetbrains.annotations.Nls

class MyJsonSchemaProvider : JsonSchemaFileProvider {
    override fun isAvailable(file: VirtualFile): Boolean = file.name == "sushi-config.yaml"
    override fun getName(): @Nls String = "sushi-config.yaml schema"
    override fun getSchemaType(): SchemaType = SchemaType.embeddedSchema
    override fun getSchemaVersion(): JsonSchemaVersion = JsonSchemaVersion.SCHEMA_2020_12
    override fun getSchemaFile(): VirtualFile? =
        JsonSchemaProviderFactory.getResourceFile(javaClass, "/schema.json")
}
```

<p>The following methods are implemented:</p>

<ul>
    <li>
        <code>isAvailable(VirtualFile)</code>: the IDE will query this method with the file for which it wants to
        determine if the JSON Schema applies or not. In this example, I simply check if the file name is
        <code>sushi-config.yaml</code>.
    </li>
    <li><code>getName()</code>: returns the name of the schema, and will be displayed in the IDE.</li>
    <li><code>getSchemaType()</code>: I actually have no idea about this one, I saw no difference changing the value.</li>
    <li>
        <code>getSchemaVersion()</code> (optional): the JSON Schema version that is implemented. I'm not sure if there's
        any reason to stick with an older version than <code>2020-12</code>, unless you're dealing with legacy schemas.
    </li>
    <li>
        <code>getSchemaFile()</code>: returns the schema file as a <code>VirtualFile</code>. In this example, I am
        loading it from the plugin resources (meaning the file is at <em>my-plugin/src/main/resources/schema.json</em>).
        There's a nice utility method to load a resource as a <code>VirtualFile</code> in
        {{< a/ext "https://github.com/JetBrains/intellij-community/blob/master/json/backend/src/com/jetbrains/jsonSchema/extension/JsonSchemaProviderFactory.java" "JsonSchemaProviderFactory" >}}.
    </li>
</ul>

<p>The next step is to create a factory for our provider. This is really straightforward:</p>

```kotlin {title="MyJsonSchemaProviderFactory.kt"}
package org.jetbrains.plugins.template

import com.intellij.openapi.project.Project
import com.jetbrains.jsonSchema.extension.JsonSchemaFileProvider
import com.jetbrains.jsonSchema.extension.JsonSchemaProviderFactory

class MyJsonSchemaProviderFactory : JsonSchemaProviderFactory {
    override fun getProviders(project: Project): List<​JsonSchemaFileProvider> = listOf(MyJsonSchemaProvider())
}
```

{{< h3 "A registration" >}}

<p>
    The last step is to register our factory in the plugin configuration file, and declare a runtime dependency on the
    JSON plugin.
    Since it's a plugin, it could be unavailable at runtime, and IntelliJ offers us two choices to deal with that:
</p>

<ol>
    <li>refuse to load our plugin, because we require the JSON plugin;</li>
    <li>continue to load our plugin, but disable that feature.</li>
</ol>

<p>
    Which solution to implement depends on the context of the developed plugin.
    At the time of writing, I am unable to disable the JSON plugin in my IDEs, so I am unsure if that situation is
    really possible, but I choose the second solution for my plugin – better safe than sorry.
    The first solution is simply implemented by declaring a mandatory dependency on the JSON plugin:
</p>

```xml {title="plugin.xml (mandatory dependency)"}
<!-- Plugin Configuration File. Read more: https://plugins.jetbrains.com/docs/intellij/plugin-configuration-file.html -->
<idea-plugin>
    <id>org.jetbrains.plugins.template</id>
    <name>IntelliJ Platform Plugin Template</name>
    <depends>com.intellij.modules.platform</depends>
    <depends>com.intellij.modules.json</depends>
    <extensions defaultExtensionNs="com.intellij">
        <!-- Other extensions… -->
    </extensions>
    <extensions defaultExtensionNs="JavaScript.JsonSchema">
        <ProviderFactory implementation="org.jetbrains.plugins.template.MyJsonSchemaProviderFactory"/>
    </extensions>
</idea-plugin>
```

<p>
    The second solution is implemented by declaring an optional dependency on the JSON plugin, and creating a second
    plugin configuration file that is only loaded when the JSON plugin is available.
    You can name it as you want.
</p>

```xml {title="plugin.xml (optional dependency)"}
<idea-plugin>
    <id>org.jetbrains.plugins.template</id>
    <name>IntelliJ Platform Plugin Template</name>
    <depends>com.intellij.modules.platform</depends>
    <depends optional="true" config-file="plugin_with_json.xml">com.intellij.modules.json</depends>
</idea-plugin>
```

```xml {title="plugin_with_json.xml (optional dependency)"}
<idea-plugin>
    <extensions defaultExtensionNs="JavaScript.JsonSchema">
        <ProviderFactory implementation="org.jetbrains.plugins.template.MyJsonSchemaProviderFactory"/>
    </extensions>
</idea-plugin>
```

{{< h2 "The result" >}}

<p>
    Here is the result of the implementation in my plugin, when editing a <code>sushi-config.yaml</code> file:
</p>

{{< figure src="syntax_highlighting.png" alt="The 'sushi-config.yaml' file opened in the IDE" caption="The 'sushi-config.yaml' file opened in the IDE" >}}
<br>
{{< figure src="autocompletion.png" alt="Autocompletion suggestions based on the JSON Schema" caption="Autocompletion suggestions based on the JSON Schema" >}}
<br>
{{< figure src="error.png" alt="An example of validation error" caption="An example of validation error" >}}
<br>
{{< figure src="description.png" alt="The description shown for the element 'dependencies'" caption="The description shown for the element 'dependencies'" >}}