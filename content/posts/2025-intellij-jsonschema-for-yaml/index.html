---
title: "How to enable JSON or YAML validation with JSON Schemas in IntelliJ"
date: 2025-12-28
draft: true
tags: ['Software', 'IDE', 'Development']
description: "The blog post is describing how ."
---

<p>
    This is another article about plugin development for IntelliJ-based IDEs.
    In this article, I am describing how to implement some support for JSON or YAML files using a JSON Schema.
    While the JSON support is expected, the YAML support is a bit more surprising.
    It is possible because JSON and YAML are very similar formats, YAML 1.2 even being a superset of JSON.
</p>

<p>
    I recently implemented that trick in my plugin
    {{< a/ext "https://github.com/qligier/jetbrains-plugin-fss" "FHIR® and SUSHI Support" >}} to provide a better
    experience while working with a specific YAML file (the <code>sushi-config.yaml</code> file).
    I discovered that neat feature in the
    {{< a/ext "https://www.jetbrains.com/help/idea/yaml.html#json_schema" "YAML documentation" >}}, but I had to use the
    {{< a/ext "https://plugins.jetbrains.com/intellij-platform-explorer/extensions?extensions=JavaScript.JsonSchema.ProviderFactory" "IntelliJ Platform Explorer" >}}
    to discover how a plugin could register a new JSON Schema in the IDE.
    That topic isn't covered by the
    {{< a/ext "https://plugins.jetbrains.com/docs/intellij/welcome.html" "IntelliJ Platform SDK Documentation" >}}
    documentation, so I am sharing my findings here.
</p>

{{< h2 "Supported features" >}}

<p>
    The features automatically provided by the IntelliJ SDK (at the time of writing) when a JSON Schema is enabled are:
</p>

<ul>
    <li>Autocompletion suggestions based on the schema</li>
    <li>Validation of values based on the defined type and constraints</li>
    <li><code>description</code> fields are used to annotate the YAML elements;</li>
    <li>
        <code></code> is properly
        enforced;
    </li>
    <li>
        <code>definitions</code> are properly handled internally;
    </li>
</ul>

<p>
    Notably, the following features are NOT supported:
</p>

<ul>
    <li>
        Despite setting
        <code>{{< a/ext "https://json-schema.org/understanding-json-schema/reference/object#additionalproperties" "additionalProperties" >}}</code>
        on an object, extra properties are not marked as errors.
    </li>
    <li>Others?</li>
</ul>

{{< h2 "The implementation" >}}

<p>
    Let's go into the implementation details.
    For these examples, I am using the
    {{< a/ext "https://github.com/JetBrains/intellij-platform-plugin-template" "IntelliJ Platform Plugin Template" >}},
    but your plugin structure may differ slightly.
</p>

{{< h3 "A JSON Schema" >}}

<p>
    First, we need a JSON Schema to work with.
    Creating a JSON Schema is out of the scope of this article, but there are many resources online to help with that,
    and I found it rather easy to write one manually.
    I'm also sure there are good tools with graphical interfaces to help visualizing and editing the schemas.
</p>

<p>
    Once you have your schema, you need to add it to your plugin resources.
    In the plugin template structure, that would be under <em>my-plugin/src/main/resources/</em>.
    For this example, I simply named my schema file <code>schema.json</code>.
</p>

{{< h3 "A provider" >}}

<p>
    Next, we create a new class extending <code>JsonSchemaFileProvider</code> to provide our schema to the IDE.
    But that interface we are extending is not part of the standard IntelliJ API, but is an additional plugin that we
    need to declare as a build dependency in the Gradle configuration (despite its name, it's not a module but a plugin):
</p>

```properties {title="gradle.properties"}
platformBundledPlugins = com.intellij.modules.json
```

<p>Or with the regular `gradle.build.kts` file:</p>

```kotlin {title="gradle.build.kts"}
dependencies {
    // …
    // IntelliJ Platform Gradle Plugin Dependencies Extension - read more: https://plugins.jetbrains.com/docs/intellij/tools-intellij-platform-gradle-plugin-dependencies-extension.html
    intellijPlatform {
        bundledPlugin("com.intellij.modules.json")
    }
}
```

<p>
    Now, we can implement our provider:
</p>

```kotlin {title="MyJsonSchemaProvider.kt"}
package org.jetbrains.plugins.template

import com.intellij.openapi.vfs.VirtualFile
import com.jetbrains.jsonSchema.extension.JsonSchemaFileProvider
import com.jetbrains.jsonSchema.extension.JsonSchemaProviderFactory
import com.jetbrains.jsonSchema.extension.SchemaType
import com.jetbrains.jsonSchema.impl.JsonSchemaVersion
import org.jetbrains.annotations.Nls

class MyJsonSchemaProvider : JsonSchemaFileProvider {
    override fun isAvailable(file: VirtualFile): Boolean = file.name == "sushi-config.yaml"
    override fun getName(): @Nls String = "sushi-config.yaml schema"
    override fun getSchemaType(): SchemaType = SchemaType.embeddedSchema
    override fun getSchemaVersion(): JsonSchemaVersion = JsonSchemaVersion.SCHEMA_2020_12
    override fun getSchemaFile(): VirtualFile? =
        JsonSchemaProviderFactory.getResourceFile(javaClass, "/schema.json")
}
```

<p>The following methods are implemented:</p>

<ul>
    <li>
        <code>isAvailable(VirtualFile)</code>: the IDE will query this method with the file for which it wants to
        determine if the JSON Schema applies or not. In this example, I simply check if the file name is
        <code>sushi-config.yaml</code>.
    </li>
    <li><code>getName()</code>: returns the name of the schema, and will be displayed in the IDE.</li>
    <li><code>getSchemaType()</code>: ?</li>
    <li>
        <code>getSchemaVersion()</code> (optional): the JSON Schema version that is implemented. I'm not sure if there's
        any reason to stick with an older version than <code>2020-12</code>, unless you're dealing with legacy schemas.
    </li>
    <li>
        <code>getSchemaFile()</code>: returns the schema file as a <code>VirtualFile</code>. In this example, I am
        loading it from the plugin resources (meaning the file is at <em>my-plugin/src/main/resources/schema.json</em>).
        There's a nice utility method to load a resource as a <code>VirtualFile</code> in
        {{< a/ext "https://github.com/JetBrains/intellij-community/blob/master/json/backend/src/com/jetbrains/jsonSchema/extension/JsonSchemaProviderFactory.java" "JsonSchemaProviderFactory" >}}.
    </li>
</ul>

<p>The next step is to create a factory for our provider. This is really straightforward:</p>

```kotlin {title="MyJsonSchemaProviderFactory.kt"}
package org.jetbrains.plugins.template

import com.intellij.openapi.project.Project
import com.jetbrains.jsonSchema.extension.JsonSchemaFileProvider
import com.jetbrains.jsonSchema.extension.JsonSchemaProviderFactory

class MyJsonSchemaProviderFactory : JsonSchemaProviderFactory {
    override fun getProviders(project: Project): List<JsonSchemaFileProvider> = listOf(MyJsonSchemaProvider())
}
```
<!-- </JsonSchemaFileProvider> -->

{{< h3 "A registration" >}}

<p>
    The last step is to register our factory in the plugin configuration file, and declare a runtime dependency on the
    JSON plugin.
    Since it's a plugin, it could be unavailable at runtime, and IntelliJ offers us two choices to deal with that:
</p>

<ol>
    <li>refuse to load our plugin, because we require the JSON plugin;</li>
    <li>continue to load our plugin, but disable that feature.</li>
</ol>

<p>
    Which solution to implement depends on the context of the developed plugin.
    At the time of writing, I am unable to disable the JSON plugin in my IDEs, so I am unsure if that situation is
    really possible, but I choose the second solution for my plugin – better safe than sorry.
    The first solution is simply implemented by declaring a mandatory dependency on the JSON plugin:
</p>
```xml {title="plugin.xml (mandatory dependency)"}
<!-- Plugin Configuration File. Read more: https://plugins.jetbrains.com/docs/intellij/plugin-configuration-file.html -->
<idea-plugin>
    <id>org.jetbrains.plugins.template</id>
    <name>IntelliJ Platform Plugin Template</name>
    <depends>com.intellij.modules.platform</depends>
    <depends>com.intellij.modules.json</depends>
    <extensions defaultExtensionNs="com.intellij">
        <!-- Other extensions… -->
    </extensions>
    <extensions defaultExtensionNs="JavaScript.JsonSchema">
        <ProviderFactory implementation="org.jetbrains.plugins.template.MyJsonSchemaProviderFactory"/>
    </extensions>
</idea-plugin>
```

<p>
    The second solution is implemented by declaring a optional dependency on the JSON plugin, and creating a second
    plugin configuration file that is only loaded when the JSON plugin is available.
    You can name it as you want.
</p>

```xml {title="plugin.xml (optional dependency)"}
<idea-plugin>
    <id>org.jetbrains.plugins.template</id>
    <name>IntelliJ Platform Plugin Template</name>
    <depends>com.intellij.modules.platform</depends>
    <depends optional="false" config-file="plugin_with_json.xml">com.intellij.modules.json</depends>
</idea-plugin>
```

```xml {title="plugin_with_json.xml (optional dependency)"}
<idea-plugin>
    <extensions defaultExtensionNs="JavaScript.JsonSchema">
        <ProviderFactory
                implementation="ch.qligier.jetbrains.plugin.fss.sushiconfig.SushiConfigSchemaProviderFactory"/>
    </extensions>
</idea-plugin>
```

{{< h2 "Supported features" >}}

<p>
    That's it,
</p>